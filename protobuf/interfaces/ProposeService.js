/**
 * Flowtype definitions for ProposeService
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.9.2
 */

import * as $protobuf from "protobufjs";
declare var coop: typeof npm$namespace$coop;

declare var npm$namespace$coop: {
  rchain: typeof npm$namespace$coop$rchain
};

declare var npm$namespace$coop$rchain: {
  casper: typeof npm$namespace$coop$rchain$casper
};

declare var npm$namespace$coop$rchain$casper: {
  protocol: typeof npm$namespace$coop$rchain$casper$protocol
};

declare var npm$namespace$coop$rchain$casper$protocol: {
  ProposeService: typeof coop$rchain$casper$protocol$ProposeService,
  PrintUnmatchedSendsQuery: typeof coop$rchain$casper$protocol$PrintUnmatchedSendsQuery,
  HasBlockRequest: typeof coop$rchain$casper$protocol$HasBlockRequest,
  HasBlock: typeof coop$rchain$casper$protocol$HasBlock,
  BlockRequest: typeof coop$rchain$casper$protocol$BlockRequest,
  ForkChoiceTipRequest: typeof coop$rchain$casper$protocol$ForkChoiceTipRequest,
  ApprovedBlockCandidate: typeof coop$rchain$casper$protocol$ApprovedBlockCandidate,
  UnapprovedBlock: typeof coop$rchain$casper$protocol$UnapprovedBlock,
  Signature: typeof coop$rchain$casper$protocol$Signature,
  BlockApproval: typeof coop$rchain$casper$protocol$BlockApproval,
  ApprovedBlock: typeof coop$rchain$casper$protocol$ApprovedBlock,
  ApprovedBlockRequest: typeof coop$rchain$casper$protocol$ApprovedBlockRequest,
  NoApprovedBlockAvailable: typeof coop$rchain$casper$protocol$NoApprovedBlockAvailable,
  BlockMessage: typeof coop$rchain$casper$protocol$BlockMessage,
  BlockMetadataInternal: typeof coop$rchain$casper$protocol$BlockMetadataInternal,
  Header: typeof coop$rchain$casper$protocol$Header,
  DeployData: typeof coop$rchain$casper$protocol$DeployData,
  ProcessedDeploy: typeof coop$rchain$casper$protocol$ProcessedDeploy,
  Body: typeof coop$rchain$casper$protocol$Body,
  Justification: typeof coop$rchain$casper$protocol$Justification,
  RChainState: typeof coop$rchain$casper$protocol$RChainState,
  Event: typeof coop$rchain$casper$protocol$Event,
  ProduceEvent: typeof coop$rchain$casper$protocol$ProduceEvent,
  ConsumeEvent: typeof coop$rchain$casper$protocol$ConsumeEvent,
  CommEvent: typeof coop$rchain$casper$protocol$CommEvent,
  Bond: typeof coop$rchain$casper$protocol$Bond
};
declare class coop$rchain$casper$protocol$ProposeService
  mixins $protobuf.rpc.Service {
  constructor(
    rpcImpl: $protobuf.RPCImpl,
    requestDelimited?: boolean,
    responseDelimited?: boolean
  ): this;
  static create(
    rpcImpl: $protobuf.RPCImpl,
    requestDelimited?: boolean,
    responseDelimited?: boolean
  ): coop$rchain$casper$protocol$ProposeService;
  propose(
    request: coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery,
    callback: coop$rchain$casper$protocol$ProposeService$proposeCallback
  ): void;
  propose(
    request: coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery
  ): Promise<Either>;
}

declare type coop$rchain$casper$protocol$ProposeService$proposeCallback = (
  error: Error | null,
  response?: Either
) => void;

declare interface coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery {
  printUnmatchedSends?: boolean | null;
}

declare class coop$rchain$casper$protocol$PrintUnmatchedSendsQuery
  mixins coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery {
  constructor(
    properties?: coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery
  ): this;
  printUnmatchedSends: boolean;
  static create(
    properties?: coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery
  ): coop$rchain$casper$protocol$PrintUnmatchedSendsQuery;
  static encode(
    message: coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IPrintUnmatchedSendsQuery,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$PrintUnmatchedSendsQuery;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$PrintUnmatchedSendsQuery;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$PrintUnmatchedSendsQuery;
  static toObject(
    message: coop$rchain$casper$protocol$PrintUnmatchedSendsQuery,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IHasBlockRequest {
  hash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$HasBlockRequest
  mixins coop$rchain$casper$protocol$IHasBlockRequest {
  constructor(properties?: coop$rchain$casper$protocol$IHasBlockRequest): this;
  hash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IHasBlockRequest
  ): coop$rchain$casper$protocol$HasBlockRequest;
  static encode(
    message: coop$rchain$casper$protocol$IHasBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IHasBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$HasBlockRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$HasBlockRequest;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$HasBlockRequest;
  static toObject(
    message: coop$rchain$casper$protocol$HasBlockRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IHasBlock {
  hash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$HasBlock
  mixins coop$rchain$casper$protocol$IHasBlock {
  constructor(properties?: coop$rchain$casper$protocol$IHasBlock): this;
  hash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IHasBlock
  ): coop$rchain$casper$protocol$HasBlock;
  static encode(
    message: coop$rchain$casper$protocol$IHasBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IHasBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$HasBlock;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$HasBlock;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$HasBlock;
  static toObject(
    message: coop$rchain$casper$protocol$HasBlock,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IBlockRequest {
  hash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$BlockRequest
  mixins coop$rchain$casper$protocol$IBlockRequest {
  constructor(properties?: coop$rchain$casper$protocol$IBlockRequest): this;
  hash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockRequest
  ): coop$rchain$casper$protocol$BlockRequest;
  static encode(
    message: coop$rchain$casper$protocol$IBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockRequest;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$BlockRequest;
  static toObject(
    message: coop$rchain$casper$protocol$BlockRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IForkChoiceTipRequest {}

declare class coop$rchain$casper$protocol$ForkChoiceTipRequest
  mixins coop$rchain$casper$protocol$IForkChoiceTipRequest {
  constructor(
    properties?: coop$rchain$casper$protocol$IForkChoiceTipRequest
  ): this;
  static create(
    properties?: coop$rchain$casper$protocol$IForkChoiceTipRequest
  ): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static encode(
    message: coop$rchain$casper$protocol$IForkChoiceTipRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IForkChoiceTipRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static toObject(
    message: coop$rchain$casper$protocol$ForkChoiceTipRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IApprovedBlockCandidate {
  block?: coop$rchain$casper$protocol$IBlockMessage | null;
  requiredSigs?: number | null;
}

declare class coop$rchain$casper$protocol$ApprovedBlockCandidate
  mixins coop$rchain$casper$protocol$IApprovedBlockCandidate {
  constructor(
    properties?: coop$rchain$casper$protocol$IApprovedBlockCandidate
  ): this;
  block?: coop$rchain$casper$protocol$IBlockMessage | null;
  requiredSigs: number;
  static create(
    properties?: coop$rchain$casper$protocol$IApprovedBlockCandidate
  ): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static encode(
    message: coop$rchain$casper$protocol$IApprovedBlockCandidate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IApprovedBlockCandidate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static toObject(
    message: coop$rchain$casper$protocol$ApprovedBlockCandidate,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IUnapprovedBlock {
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  timestamp?: number | Long | null;
  duration?: number | Long | null;
}

declare class coop$rchain$casper$protocol$UnapprovedBlock
  mixins coop$rchain$casper$protocol$IUnapprovedBlock {
  constructor(properties?: coop$rchain$casper$protocol$IUnapprovedBlock): this;
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  timestamp: number | Long;
  duration: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IUnapprovedBlock
  ): coop$rchain$casper$protocol$UnapprovedBlock;
  static encode(
    message: coop$rchain$casper$protocol$IUnapprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IUnapprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$UnapprovedBlock;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$UnapprovedBlock;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$UnapprovedBlock;
  static toObject(
    message: coop$rchain$casper$protocol$UnapprovedBlock,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$ISignature {
  publicKey?: Uint8Array | null;
  algorithm?: string | null;
  sig?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Signature
  mixins coop$rchain$casper$protocol$ISignature {
  constructor(properties?: coop$rchain$casper$protocol$ISignature): this;
  publicKey: Uint8Array;
  algorithm: string;
  sig: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$ISignature
  ): coop$rchain$casper$protocol$Signature;
  static encode(
    message: coop$rchain$casper$protocol$ISignature,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$ISignature,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Signature;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Signature;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$Signature;
  static toObject(
    message: coop$rchain$casper$protocol$Signature,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IBlockApproval {
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sig?: coop$rchain$casper$protocol$ISignature | null;
}

declare class coop$rchain$casper$protocol$BlockApproval
  mixins coop$rchain$casper$protocol$IBlockApproval {
  constructor(properties?: coop$rchain$casper$protocol$IBlockApproval): this;
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sig?: coop$rchain$casper$protocol$ISignature | null;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockApproval
  ): coop$rchain$casper$protocol$BlockApproval;
  static encode(
    message: coop$rchain$casper$protocol$IBlockApproval,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockApproval,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockApproval;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockApproval;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$BlockApproval;
  static toObject(
    message: coop$rchain$casper$protocol$BlockApproval,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IApprovedBlock {
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sigs?: coop$rchain$casper$protocol$ISignature[] | null;
}

declare class coop$rchain$casper$protocol$ApprovedBlock
  mixins coop$rchain$casper$protocol$IApprovedBlock {
  constructor(properties?: coop$rchain$casper$protocol$IApprovedBlock): this;
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sigs: coop$rchain$casper$protocol$ISignature[];
  static create(
    properties?: coop$rchain$casper$protocol$IApprovedBlock
  ): coop$rchain$casper$protocol$ApprovedBlock;
  static encode(
    message: coop$rchain$casper$protocol$IApprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IApprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ApprovedBlock;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ApprovedBlock;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$ApprovedBlock;
  static toObject(
    message: coop$rchain$casper$protocol$ApprovedBlock,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IApprovedBlockRequest {
  identifier?: string | null;
}

declare class coop$rchain$casper$protocol$ApprovedBlockRequest
  mixins coop$rchain$casper$protocol$IApprovedBlockRequest {
  constructor(
    properties?: coop$rchain$casper$protocol$IApprovedBlockRequest
  ): this;
  identifier: string;
  static create(
    properties?: coop$rchain$casper$protocol$IApprovedBlockRequest
  ): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static encode(
    message: coop$rchain$casper$protocol$IApprovedBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IApprovedBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static toObject(
    message: coop$rchain$casper$protocol$ApprovedBlockRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$INoApprovedBlockAvailable {
  identifier?: string | null;
  nodeIdentifer?: string | null;
}

declare class coop$rchain$casper$protocol$NoApprovedBlockAvailable
  mixins coop$rchain$casper$protocol$INoApprovedBlockAvailable {
  constructor(
    properties?: coop$rchain$casper$protocol$INoApprovedBlockAvailable
  ): this;
  identifier: string;
  nodeIdentifer: string;
  static create(
    properties?: coop$rchain$casper$protocol$INoApprovedBlockAvailable
  ): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static encode(
    message: coop$rchain$casper$protocol$INoApprovedBlockAvailable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$INoApprovedBlockAvailable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static toObject(
    message: coop$rchain$casper$protocol$NoApprovedBlockAvailable,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IBlockMessage {
  blockHash?: Uint8Array | null;
  header?: coop$rchain$casper$protocol$IHeader | null;
  body?: coop$rchain$casper$protocol$IBody | null;
  justifications?: coop$rchain$casper$protocol$IJustification[] | null;
  sender?: Uint8Array | null;
  seqNum?: number | null;
  sig?: Uint8Array | null;
  sigAlgorithm?: string | null;
  shardId?: string | null;
  extraBytes?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$BlockMessage
  mixins coop$rchain$casper$protocol$IBlockMessage {
  constructor(properties?: coop$rchain$casper$protocol$IBlockMessage): this;
  blockHash: Uint8Array;
  header?: coop$rchain$casper$protocol$IHeader | null;
  body?: coop$rchain$casper$protocol$IBody | null;
  justifications: coop$rchain$casper$protocol$IJustification[];
  sender: Uint8Array;
  seqNum: number;
  sig: Uint8Array;
  sigAlgorithm: string;
  shardId: string;
  extraBytes: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockMessage
  ): coop$rchain$casper$protocol$BlockMessage;
  static encode(
    message: coop$rchain$casper$protocol$IBlockMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockMessage;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockMessage;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$BlockMessage;
  static toObject(
    message: coop$rchain$casper$protocol$BlockMessage,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IBlockMetadataInternal {
  blockHash?: Uint8Array | null;
  parents?: Uint8Array[] | null;
  sender?: Uint8Array | null;
  justifications?: coop$rchain$casper$protocol$IJustification[] | null;
  bonds?: coop$rchain$casper$protocol$IBond[] | null;
  blockNum?: number | Long | null;
  seqNum?: number | null;
  invalid?: boolean | null;
}

declare class coop$rchain$casper$protocol$BlockMetadataInternal
  mixins coop$rchain$casper$protocol$IBlockMetadataInternal {
  constructor(
    properties?: coop$rchain$casper$protocol$IBlockMetadataInternal
  ): this;
  blockHash: Uint8Array;
  parents: Uint8Array[];
  sender: Uint8Array;
  justifications: coop$rchain$casper$protocol$IJustification[];
  bonds: coop$rchain$casper$protocol$IBond[];
  blockNum: number | Long;
  seqNum: number;
  invalid: boolean;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockMetadataInternal
  ): coop$rchain$casper$protocol$BlockMetadataInternal;
  static encode(
    message: coop$rchain$casper$protocol$IBlockMetadataInternal,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockMetadataInternal,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockMetadataInternal;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockMetadataInternal;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$BlockMetadataInternal;
  static toObject(
    message: coop$rchain$casper$protocol$BlockMetadataInternal,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IHeader {
  parentsHashList?: Uint8Array[] | null;
  postStateHash?: Uint8Array | null;
  deploysHash?: Uint8Array | null;
  timestamp?: number | Long | null;
  version?: number | Long | null;
  deployCount?: number | null;
  extraBytes?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Header
  mixins coop$rchain$casper$protocol$IHeader {
  constructor(properties?: coop$rchain$casper$protocol$IHeader): this;
  parentsHashList: Uint8Array[];
  postStateHash: Uint8Array;
  deploysHash: Uint8Array;
  timestamp: number | Long;
  version: number | Long;
  deployCount: number;
  extraBytes: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IHeader
  ): coop$rchain$casper$protocol$Header;
  static encode(
    message: coop$rchain$casper$protocol$IHeader,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IHeader,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Header;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Header;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$Header;
  static toObject(
    message: coop$rchain$casper$protocol$Header,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IDeployData {
  deployer?: Uint8Array | null;
  term?: string | null;
  timestamp?: number | Long | null;
  sig?: Uint8Array | null;
  sigAlgorithm?: string | null;
  phloPrice?: number | Long | null;
  phloLimit?: number | Long | null;
  validAfterBlockNumber?: number | Long | null;
}

declare class coop$rchain$casper$protocol$DeployData
  mixins coop$rchain$casper$protocol$IDeployData {
  constructor(properties?: coop$rchain$casper$protocol$IDeployData): this;
  deployer: Uint8Array;
  term: string;
  timestamp: number | Long;
  sig: Uint8Array;
  sigAlgorithm: string;
  phloPrice: number | Long;
  phloLimit: number | Long;
  validAfterBlockNumber: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IDeployData
  ): coop$rchain$casper$protocol$DeployData;
  static encode(
    message: coop$rchain$casper$protocol$IDeployData,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IDeployData,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$DeployData;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$DeployData;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$DeployData;
  static toObject(
    message: coop$rchain$casper$protocol$DeployData,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IProcessedDeploy {
  deploy?: coop$rchain$casper$protocol$IDeployData | null;
  cost?: IPCost | null;
  deployLog?: coop$rchain$casper$protocol$IEvent[] | null;
  paymentLog?: coop$rchain$casper$protocol$IEvent[] | null;
  errored?: boolean | null;
}

declare class coop$rchain$casper$protocol$ProcessedDeploy
  mixins coop$rchain$casper$protocol$IProcessedDeploy {
  constructor(properties?: coop$rchain$casper$protocol$IProcessedDeploy): this;
  deploy?: coop$rchain$casper$protocol$IDeployData | null;
  cost?: IPCost | null;
  deployLog: coop$rchain$casper$protocol$IEvent[];
  paymentLog: coop$rchain$casper$protocol$IEvent[];
  errored: boolean;
  static create(
    properties?: coop$rchain$casper$protocol$IProcessedDeploy
  ): coop$rchain$casper$protocol$ProcessedDeploy;
  static encode(
    message: coop$rchain$casper$protocol$IProcessedDeploy,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IProcessedDeploy,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ProcessedDeploy;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ProcessedDeploy;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$ProcessedDeploy;
  static toObject(
    message: coop$rchain$casper$protocol$ProcessedDeploy,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IBody {
  state?: coop$rchain$casper$protocol$IRChainState | null;
  deploys?: coop$rchain$casper$protocol$IProcessedDeploy[] | null;
  extraBytes?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Body
  mixins coop$rchain$casper$protocol$IBody {
  constructor(properties?: coop$rchain$casper$protocol$IBody): this;
  state?: coop$rchain$casper$protocol$IRChainState | null;
  deploys: coop$rchain$casper$protocol$IProcessedDeploy[];
  extraBytes: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IBody
  ): coop$rchain$casper$protocol$Body;
  static encode(
    message: coop$rchain$casper$protocol$IBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Body;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Body;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$Body;
  static toObject(
    message: coop$rchain$casper$protocol$Body,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IJustification {
  validator?: Uint8Array | null;
  latestBlockHash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Justification
  mixins coop$rchain$casper$protocol$IJustification {
  constructor(properties?: coop$rchain$casper$protocol$IJustification): this;
  validator: Uint8Array;
  latestBlockHash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IJustification
  ): coop$rchain$casper$protocol$Justification;
  static encode(
    message: coop$rchain$casper$protocol$IJustification,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IJustification,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Justification;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Justification;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$Justification;
  static toObject(
    message: coop$rchain$casper$protocol$Justification,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IRChainState {
  preStateHash?: Uint8Array | null;
  postStateHash?: Uint8Array | null;
  bonds?: coop$rchain$casper$protocol$IBond[] | null;
  blockNumber?: number | Long | null;
}

declare class coop$rchain$casper$protocol$RChainState
  mixins coop$rchain$casper$protocol$IRChainState {
  constructor(properties?: coop$rchain$casper$protocol$IRChainState): this;
  preStateHash: Uint8Array;
  postStateHash: Uint8Array;
  bonds: coop$rchain$casper$protocol$IBond[];
  blockNumber: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IRChainState
  ): coop$rchain$casper$protocol$RChainState;
  static encode(
    message: coop$rchain$casper$protocol$IRChainState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IRChainState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$RChainState;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$RChainState;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$RChainState;
  static toObject(
    message: coop$rchain$casper$protocol$RChainState,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IEvent {
  produce?: coop$rchain$casper$protocol$IProduceEvent | null;
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  comm?: coop$rchain$casper$protocol$ICommEvent | null;
}

declare class coop$rchain$casper$protocol$Event
  mixins coop$rchain$casper$protocol$IEvent {
  constructor(properties?: coop$rchain$casper$protocol$IEvent): this;
  produce?: coop$rchain$casper$protocol$IProduceEvent | null;
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  comm?: coop$rchain$casper$protocol$ICommEvent | null;
  event_instance?: "produce" | "consume" | "comm";
  static create(
    properties?: coop$rchain$casper$protocol$IEvent
  ): coop$rchain$casper$protocol$Event;
  static encode(
    message: coop$rchain$casper$protocol$IEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Event;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Event;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$Event;
  static toObject(
    message: coop$rchain$casper$protocol$Event,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IProduceEvent {
  channelsHash?: Uint8Array | null;
  hash?: Uint8Array | null;
  sequenceNumber?: number | null;
}

declare class coop$rchain$casper$protocol$ProduceEvent
  mixins coop$rchain$casper$protocol$IProduceEvent {
  constructor(properties?: coop$rchain$casper$protocol$IProduceEvent): this;
  channelsHash: Uint8Array;
  hash: Uint8Array;
  sequenceNumber: number;
  static create(
    properties?: coop$rchain$casper$protocol$IProduceEvent
  ): coop$rchain$casper$protocol$ProduceEvent;
  static encode(
    message: coop$rchain$casper$protocol$IProduceEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IProduceEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ProduceEvent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ProduceEvent;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$ProduceEvent;
  static toObject(
    message: coop$rchain$casper$protocol$ProduceEvent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IConsumeEvent {
  channelsHashes?: Uint8Array[] | null;
  hash?: Uint8Array | null;
  sequenceNumber?: number | null;
}

declare class coop$rchain$casper$protocol$ConsumeEvent
  mixins coop$rchain$casper$protocol$IConsumeEvent {
  constructor(properties?: coop$rchain$casper$protocol$IConsumeEvent): this;
  channelsHashes: Uint8Array[];
  hash: Uint8Array;
  sequenceNumber: number;
  static create(
    properties?: coop$rchain$casper$protocol$IConsumeEvent
  ): coop$rchain$casper$protocol$ConsumeEvent;
  static encode(
    message: coop$rchain$casper$protocol$IConsumeEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IConsumeEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ConsumeEvent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ConsumeEvent;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$ConsumeEvent;
  static toObject(
    message: coop$rchain$casper$protocol$ConsumeEvent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$ICommEvent {
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  produces?: coop$rchain$casper$protocol$IProduceEvent[] | null;
}

declare class coop$rchain$casper$protocol$CommEvent
  mixins coop$rchain$casper$protocol$ICommEvent {
  constructor(properties?: coop$rchain$casper$protocol$ICommEvent): this;
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  produces: coop$rchain$casper$protocol$IProduceEvent[];
  static create(
    properties?: coop$rchain$casper$protocol$ICommEvent
  ): coop$rchain$casper$protocol$CommEvent;
  static encode(
    message: coop$rchain$casper$protocol$ICommEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$ICommEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$CommEvent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$CommEvent;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$CommEvent;
  static toObject(
    message: coop$rchain$casper$protocol$CommEvent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface coop$rchain$casper$protocol$IBond {
  validator?: Uint8Array | null;
  stake?: number | Long | null;
}

declare class coop$rchain$casper$protocol$Bond
  mixins coop$rchain$casper$protocol$IBond {
  constructor(properties?: coop$rchain$casper$protocol$IBond): this;
  validator: Uint8Array;
  stake: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IBond
  ): coop$rchain$casper$protocol$Bond;
  static encode(
    message: coop$rchain$casper$protocol$IBond,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBond,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Bond;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Bond;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): coop$rchain$casper$protocol$Bond;
  static toObject(
    message: coop$rchain$casper$protocol$Bond,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IPar {
  sends?: ISend[] | null;
  receives?: IReceive[] | null;
  news?: INew[] | null;
  exprs?: IExpr[] | null;
  matches?: IMatch[] | null;
  unforgeables?: IGUnforgeable[] | null;
  bundles?: IBundle[] | null;
  connectives?: IConnective[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Par mixins IPar {
  constructor(properties?: IPar): this;
  sends: ISend[];
  receives: IReceive[];
  news: INew[];
  exprs: IExpr[];
  matches: IMatch[];
  unforgeables: IGUnforgeable[];
  bundles: IBundle[];
  connectives: IConnective[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IPar): Par;
  static encode(message: IPar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IPar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Par;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Par;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Par;
  static toObject(
    message: Par,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface ITaggedContinuation {
  par_body?: IParWithRandom | null;
  scala_body_ref?: number | Long | null;
}
declare export class TaggedContinuation mixins ITaggedContinuation {
  constructor(properties?: ITaggedContinuation): this;
  par_body?: IParWithRandom | null;
  scala_body_ref: number | Long;
  tagged_cont?: "par_body" | "scala_body_ref";
  static create(properties?: ITaggedContinuation): TaggedContinuation;
  static encode(
    message: ITaggedContinuation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: ITaggedContinuation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): TaggedContinuation;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): TaggedContinuation;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): TaggedContinuation;
  static toObject(
    message: TaggedContinuation,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IParWithRandom {
  body?: IPar | null;
  randomState?: Uint8Array | null;
}
declare export class ParWithRandom mixins IParWithRandom {
  constructor(properties?: IParWithRandom): this;
  body?: IPar | null;
  randomState: Uint8Array;
  static create(properties?: IParWithRandom): ParWithRandom;
  static encode(
    message: IParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ParWithRandom;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ParWithRandom;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ParWithRandom;
  static toObject(
    message: ParWithRandom,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IPCost {
  cost?: number | Long | null;
}
declare export class PCost mixins IPCost {
  constructor(properties?: IPCost): this;
  cost: number | Long;
  static create(properties?: IPCost): PCost;
  static encode(message: IPCost, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IPCost,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): PCost;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): PCost;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): PCost;
  static toObject(
    message: PCost,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IListParWithRandom {
  pars?: IPar[] | null;
  randomState?: Uint8Array | null;
}
declare export class ListParWithRandom mixins IListParWithRandom {
  constructor(properties?: IListParWithRandom): this;
  pars: IPar[];
  randomState: Uint8Array;
  static create(properties?: IListParWithRandom): ListParWithRandom;
  static encode(
    message: IListParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IListParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ListParWithRandom;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): ListParWithRandom;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ListParWithRandom;
  static toObject(
    message: ListParWithRandom,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IVar {
  bound_var?: number | null;
  free_var?: number | null;
  wildcard?: Var$IWildcardMsg | null;
}
declare export class Var mixins IVar {
  constructor(properties?: IVar): this;
  bound_var: number;
  free_var: number;
  wildcard?: Var$IWildcardMsg | null;
  var_instance?: "bound_var" | "free_var" | "wildcard";
  static create(properties?: IVar): Var;
  static encode(message: IVar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Var;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Var;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Var;
  static toObject(
    message: Var,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
declare var Var: typeof npm$namespace$Var;

declare var npm$namespace$Var: {
  WildcardMsg: typeof Var$WildcardMsg
};
declare interface Var$IWildcardMsg {}

declare class Var$WildcardMsg mixins Var$IWildcardMsg {
  constructor(properties?: Var$IWildcardMsg): this;
  static create(properties?: Var$IWildcardMsg): Var$WildcardMsg;
  static encode(
    message: Var$IWildcardMsg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: Var$IWildcardMsg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Var$WildcardMsg;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): Var$WildcardMsg;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Var$WildcardMsg;
  static toObject(
    message: Var$WildcardMsg,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IBundle {
  body?: IPar | null;
  writeFlag?: boolean | null;
  readFlag?: boolean | null;
}
declare export class Bundle mixins IBundle {
  constructor(properties?: IBundle): this;
  body?: IPar | null;
  writeFlag: boolean;
  readFlag: boolean;
  static create(properties?: IBundle): Bundle;
  static encode(message: IBundle, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IBundle,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Bundle;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Bundle;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Bundle;
  static toObject(
    message: Bundle,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface ISend {
  chan?: IPar | null;
  data?: IPar[] | null;
  persistent?: boolean | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Send mixins ISend {
  constructor(properties?: ISend): this;
  chan?: IPar | null;
  data: IPar[];
  persistent: boolean;
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: ISend): Send;
  static encode(message: ISend, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: ISend,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Send;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Send;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Send;
  static toObject(
    message: Send,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IReceiveBind {
  patterns?: IPar[] | null;
  source?: IPar | null;
  remainder?: IVar | null;
  freeCount?: number | null;
}
declare export class ReceiveBind mixins IReceiveBind {
  constructor(properties?: IReceiveBind): this;
  patterns: IPar[];
  source?: IPar | null;
  remainder?: IVar | null;
  freeCount: number;
  static create(properties?: IReceiveBind): ReceiveBind;
  static encode(
    message: IReceiveBind,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IReceiveBind,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ReceiveBind;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ReceiveBind;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ReceiveBind;
  static toObject(
    message: ReceiveBind,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IBindPattern {
  patterns?: IPar[] | null;
  remainder?: IVar | null;
  freeCount?: number | null;
}
declare export class BindPattern mixins IBindPattern {
  constructor(properties?: IBindPattern): this;
  patterns: IPar[];
  remainder?: IVar | null;
  freeCount: number;
  static create(properties?: IBindPattern): BindPattern;
  static encode(
    message: IBindPattern,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IBindPattern,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): BindPattern;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): BindPattern;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): BindPattern;
  static toObject(
    message: BindPattern,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IListBindPatterns {
  patterns?: IBindPattern[] | null;
}
declare export class ListBindPatterns mixins IListBindPatterns {
  constructor(properties?: IListBindPatterns): this;
  patterns: IBindPattern[];
  static create(properties?: IListBindPatterns): ListBindPatterns;
  static encode(
    message: IListBindPatterns,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IListBindPatterns,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ListBindPatterns;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): ListBindPatterns;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ListBindPatterns;
  static toObject(
    message: ListBindPatterns,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IReceive {
  binds?: IReceiveBind[] | null;
  body?: IPar | null;
  persistent?: boolean | null;
  peek?: boolean | null;
  bindCount?: number | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Receive mixins IReceive {
  constructor(properties?: IReceive): this;
  binds: IReceiveBind[];
  body?: IPar | null;
  persistent: boolean;
  peek: boolean;
  bindCount: number;
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IReceive): Receive;
  static encode(message: IReceive, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IReceive,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Receive;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Receive;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Receive;
  static toObject(
    message: Receive,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface INew {
  bindCount?: number | null;
  p?: IPar | null;
  uri?: string[] | null;
  deployId?: IDeployId | null;
  deployerId?: IDeployerId | null;
  locallyFree?: Uint8Array | null;
}
declare export class New mixins INew {
  constructor(properties?: INew): this;
  bindCount: number;
  p?: IPar | null;
  uri: string[];
  deployId?: IDeployId | null;
  deployerId?: IDeployerId | null;
  locallyFree: Uint8Array;
  static create(properties?: INew): New;
  static encode(message: INew, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: INew,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): New;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): New;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): New;
  static toObject(
    message: New,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IMatchCase {
  pattern?: IPar | null;
  source?: IPar | null;
  freeCount?: number | null;
}
declare export class MatchCase mixins IMatchCase {
  constructor(properties?: IMatchCase): this;
  pattern?: IPar | null;
  source?: IPar | null;
  freeCount: number;
  static create(properties?: IMatchCase): MatchCase;
  static encode(
    message: IMatchCase,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IMatchCase,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): MatchCase;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): MatchCase;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): MatchCase;
  static toObject(
    message: MatchCase,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IMatch {
  target?: IPar | null;
  cases?: IMatchCase[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Match mixins IMatch {
  constructor(properties?: IMatch): this;
  target?: IPar | null;
  cases: IMatchCase[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IMatch): Match;
  static encode(message: IMatch, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IMatch,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Match;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Match;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Match;
  static toObject(
    message: Match,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IExpr {
  g_bool?: boolean | null;
  g_int?: number | Long | null;
  g_string?: string | null;
  g_uri?: string | null;
  g_byte_array?: Uint8Array | null;
  e_not_body?: IENot | null;
  e_neg_body?: IENeg | null;
  e_mult_body?: IEMult | null;
  e_div_body?: IEDiv | null;
  e_plus_body?: IEPlus | null;
  e_minus_body?: IEMinus | null;
  e_lt_body?: IELt | null;
  e_lte_body?: IELte | null;
  e_gt_body?: IEGt | null;
  e_gte_body?: IEGte | null;
  e_eq_body?: IEEq | null;
  e_neq_body?: IENeq | null;
  e_and_body?: IEAnd | null;
  e_or_body?: IEOr | null;
  e_var_body?: IEVar | null;
  e_list_body?: IEList | null;
  e_tuple_body?: IETuple | null;
  e_set_body?: IESet | null;
  e_map_body?: IEMap | null;
  e_method_body?: IEMethod | null;
  e_matches_body?: IEMatches | null;
  e_percent_percent_body?: IEPercentPercent | null;
  e_plus_plus_body?: IEPlusPlus | null;
  e_minus_minus_body?: IEMinusMinus | null;
  e_mod_body?: IEMod | null;
}
declare export class Expr mixins IExpr {
  constructor(properties?: IExpr): this;
  g_bool: boolean;
  g_int: number | Long;
  g_string: string;
  g_uri: string;
  g_byte_array: Uint8Array;
  e_not_body?: IENot | null;
  e_neg_body?: IENeg | null;
  e_mult_body?: IEMult | null;
  e_div_body?: IEDiv | null;
  e_plus_body?: IEPlus | null;
  e_minus_body?: IEMinus | null;
  e_lt_body?: IELt | null;
  e_lte_body?: IELte | null;
  e_gt_body?: IEGt | null;
  e_gte_body?: IEGte | null;
  e_eq_body?: IEEq | null;
  e_neq_body?: IENeq | null;
  e_and_body?: IEAnd | null;
  e_or_body?: IEOr | null;
  e_var_body?: IEVar | null;
  e_list_body?: IEList | null;
  e_tuple_body?: IETuple | null;
  e_set_body?: IESet | null;
  e_map_body?: IEMap | null;
  e_method_body?: IEMethod | null;
  e_matches_body?: IEMatches | null;
  e_percent_percent_body?: IEPercentPercent | null;
  e_plus_plus_body?: IEPlusPlus | null;
  e_minus_minus_body?: IEMinusMinus | null;
  e_mod_body?: IEMod | null;
  expr_instance?:
    | "g_bool"
    | "g_int"
    | "g_string"
    | "g_uri"
    | "g_byte_array"
    | "e_not_body"
    | "e_neg_body"
    | "e_mult_body"
    | "e_div_body"
    | "e_plus_body"
    | "e_minus_body"
    | "e_lt_body"
    | "e_lte_body"
    | "e_gt_body"
    | "e_gte_body"
    | "e_eq_body"
    | "e_neq_body"
    | "e_and_body"
    | "e_or_body"
    | "e_var_body"
    | "e_list_body"
    | "e_tuple_body"
    | "e_set_body"
    | "e_map_body"
    | "e_method_body"
    | "e_matches_body"
    | "e_percent_percent_body"
    | "e_plus_plus_body"
    | "e_minus_minus_body"
    | "e_mod_body";
  static create(properties?: IExpr): Expr;
  static encode(message: IExpr, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IExpr,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Expr;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Expr;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Expr;
  static toObject(
    message: Expr,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEList {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class EList mixins IEList {
  constructor(properties?: IEList): this;
  ps: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  remainder?: IVar | null;
  static create(properties?: IEList): EList;
  static encode(message: IEList, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEList,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EList;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EList;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EList;
  static toObject(
    message: EList,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IETuple {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class ETuple mixins IETuple {
  constructor(properties?: IETuple): this;
  ps: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IETuple): ETuple;
  static encode(message: IETuple, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IETuple,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ETuple;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ETuple;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ETuple;
  static toObject(
    message: ETuple,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IESet {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class ESet mixins IESet {
  constructor(properties?: IESet): this;
  ps: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  remainder?: IVar | null;
  static create(properties?: IESet): ESet;
  static encode(message: IESet, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IESet,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ESet;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ESet;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ESet;
  static toObject(
    message: ESet,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMap {
  kvs?: IKeyValuePair[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class EMap mixins IEMap {
  constructor(properties?: IEMap): this;
  kvs: IKeyValuePair[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  remainder?: IVar | null;
  static create(properties?: IEMap): EMap;
  static encode(message: IEMap, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMap,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMap;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMap;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMap;
  static toObject(
    message: EMap,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMethod {
  methodName?: string | null;
  target?: IPar | null;
  arguments?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class EMethod mixins IEMethod {
  constructor(properties?: IEMethod): this;
  methodName: string;
  target?: IPar | null;
  arguments: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IEMethod): EMethod;
  static encode(message: IEMethod, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMethod,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMethod;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMethod;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMethod;
  static toObject(
    message: EMethod,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IKeyValuePair {
  key?: IPar | null;
  value?: IPar | null;
}
declare export class KeyValuePair mixins IKeyValuePair {
  constructor(properties?: IKeyValuePair): this;
  key?: IPar | null;
  value?: IPar | null;
  static create(properties?: IKeyValuePair): KeyValuePair;
  static encode(
    message: IKeyValuePair,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IKeyValuePair,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): KeyValuePair;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): KeyValuePair;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): KeyValuePair;
  static toObject(
    message: KeyValuePair,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEVar {
  v?: IVar | null;
}
declare export class EVar mixins IEVar {
  constructor(properties?: IEVar): this;
  v?: IVar | null;
  static create(properties?: IEVar): EVar;
  static encode(message: IEVar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EVar;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EVar;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EVar;
  static toObject(
    message: EVar,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IENot {
  p?: IPar | null;
}
declare export class ENot mixins IENot {
  constructor(properties?: IENot): this;
  p?: IPar | null;
  static create(properties?: IENot): ENot;
  static encode(message: IENot, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENot,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENot;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENot;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ENot;
  static toObject(
    message: ENot,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IENeg {
  p?: IPar | null;
}
declare export class ENeg mixins IENeg {
  constructor(properties?: IENeg): this;
  p?: IPar | null;
  static create(properties?: IENeg): ENeg;
  static encode(message: IENeg, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENeg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENeg;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENeg;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ENeg;
  static toObject(
    message: ENeg,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMult {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMult mixins IEMult {
  constructor(properties?: IEMult): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMult): EMult;
  static encode(message: IEMult, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMult;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMult;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMult;
  static toObject(
    message: EMult,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEDiv {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EDiv mixins IEDiv {
  constructor(properties?: IEDiv): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEDiv): EDiv;
  static encode(message: IEDiv, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEDiv,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EDiv;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EDiv;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EDiv;
  static toObject(
    message: EDiv,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMod {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMod mixins IEMod {
  constructor(properties?: IEMod): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMod): EMod;
  static encode(message: IEMod, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMod,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMod;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMod;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMod;
  static toObject(
    message: EMod,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEPlus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPlus mixins IEPlus {
  constructor(properties?: IEPlus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEPlus): EPlus;
  static encode(message: IEPlus, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EPlus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EPlus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EPlus;
  static toObject(
    message: EPlus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMinus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMinus mixins IEMinus {
  constructor(properties?: IEMinus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMinus): EMinus;
  static encode(message: IEMinus, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMinus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMinus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMinus;
  static toObject(
    message: EMinus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IELt {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ELt mixins IELt {
  constructor(properties?: IELt): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IELt): ELt;
  static encode(message: IELt, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IELt,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ELt;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ELt;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ELt;
  static toObject(
    message: ELt,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IELte {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ELte mixins IELte {
  constructor(properties?: IELte): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IELte): ELte;
  static encode(message: IELte, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IELte,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ELte;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ELte;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ELte;
  static toObject(
    message: ELte,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEGt {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EGt mixins IEGt {
  constructor(properties?: IEGt): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEGt): EGt;
  static encode(message: IEGt, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEGt,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EGt;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EGt;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EGt;
  static toObject(
    message: EGt,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEGte {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EGte mixins IEGte {
  constructor(properties?: IEGte): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEGte): EGte;
  static encode(message: IEGte, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEGte,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EGte;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EGte;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EGte;
  static toObject(
    message: EGte,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEEq {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EEq mixins IEEq {
  constructor(properties?: IEEq): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEEq): EEq;
  static encode(message: IEEq, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEEq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EEq;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EEq;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EEq;
  static toObject(
    message: EEq,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IENeq {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ENeq mixins IENeq {
  constructor(properties?: IENeq): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IENeq): ENeq;
  static encode(message: IENeq, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENeq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENeq;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENeq;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ENeq;
  static toObject(
    message: ENeq,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEAnd {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EAnd mixins IEAnd {
  constructor(properties?: IEAnd): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEAnd): EAnd;
  static encode(message: IEAnd, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEAnd,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EAnd;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EAnd;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EAnd;
  static toObject(
    message: EAnd,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEOr {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EOr mixins IEOr {
  constructor(properties?: IEOr): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEOr): EOr;
  static encode(message: IEOr, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEOr,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EOr;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EOr;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EOr;
  static toObject(
    message: EOr,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMatches {
  target?: IPar | null;
  pattern?: IPar | null;
}
declare export class EMatches mixins IEMatches {
  constructor(properties?: IEMatches): this;
  target?: IPar | null;
  pattern?: IPar | null;
  static create(properties?: IEMatches): EMatches;
  static encode(
    message: IEMatches,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEMatches,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMatches;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMatches;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMatches;
  static toObject(
    message: EMatches,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEPercentPercent {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPercentPercent mixins IEPercentPercent {
  constructor(properties?: IEPercentPercent): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEPercentPercent): EPercentPercent;
  static encode(
    message: IEPercentPercent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEPercentPercent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EPercentPercent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): EPercentPercent;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EPercentPercent;
  static toObject(
    message: EPercentPercent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEPlusPlus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPlusPlus mixins IEPlusPlus {
  constructor(properties?: IEPlusPlus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEPlusPlus): EPlusPlus;
  static encode(
    message: IEPlusPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEPlusPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EPlusPlus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EPlusPlus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EPlusPlus;
  static toObject(
    message: EPlusPlus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMinusMinus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMinusMinus mixins IEMinusMinus {
  constructor(properties?: IEMinusMinus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMinusMinus): EMinusMinus;
  static encode(
    message: IEMinusMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEMinusMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMinusMinus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMinusMinus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMinusMinus;
  static toObject(
    message: EMinusMinus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IConnective {
  conn_and_body?: IConnectiveBody | null;
  conn_or_body?: IConnectiveBody | null;
  conn_not_body?: IPar | null;
  var_ref_body?: IVarRef | null;
  conn_bool?: boolean | null;
  conn_int?: boolean | null;
  conn_string?: boolean | null;
  conn_uri?: boolean | null;
  conn_byte_array?: boolean | null;
}
declare export class Connective mixins IConnective {
  constructor(properties?: IConnective): this;
  conn_and_body?: IConnectiveBody | null;
  conn_or_body?: IConnectiveBody | null;
  conn_not_body?: IPar | null;
  var_ref_body?: IVarRef | null;
  conn_bool: boolean;
  conn_int: boolean;
  conn_string: boolean;
  conn_uri: boolean;
  conn_byte_array: boolean;
  connective_instance?:
    | "conn_and_body"
    | "conn_or_body"
    | "conn_not_body"
    | "var_ref_body"
    | "conn_bool"
    | "conn_int"
    | "conn_string"
    | "conn_uri"
    | "conn_byte_array";
  static create(properties?: IConnective): Connective;
  static encode(
    message: IConnective,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IConnective,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Connective;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Connective;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Connective;
  static toObject(
    message: Connective,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IVarRef {
  index?: number | null;
  depth?: number | null;
}
declare export class VarRef mixins IVarRef {
  constructor(properties?: IVarRef): this;
  index: number;
  depth: number;
  static create(properties?: IVarRef): VarRef;
  static encode(message: IVarRef, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IVarRef,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): VarRef;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): VarRef;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): VarRef;
  static toObject(
    message: VarRef,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IConnectiveBody {
  ps?: IPar[] | null;
}
declare export class ConnectiveBody mixins IConnectiveBody {
  constructor(properties?: IConnectiveBody): this;
  ps: IPar[];
  static create(properties?: IConnectiveBody): ConnectiveBody;
  static encode(
    message: IConnectiveBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IConnectiveBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ConnectiveBody;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ConnectiveBody;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ConnectiveBody;
  static toObject(
    message: ConnectiveBody,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IDeployId {
  sig?: Uint8Array | null;
}
declare export class DeployId mixins IDeployId {
  constructor(properties?: IDeployId): this;
  sig: Uint8Array;
  static create(properties?: IDeployId): DeployId;
  static encode(
    message: IDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): DeployId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): DeployId;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): DeployId;
  static toObject(
    message: DeployId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IDeployerId {
  publicKey?: Uint8Array | null;
}
declare export class DeployerId mixins IDeployerId {
  constructor(properties?: IDeployerId): this;
  publicKey: Uint8Array;
  static create(properties?: IDeployerId): DeployerId;
  static encode(
    message: IDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): DeployerId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): DeployerId;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): DeployerId;
  static toObject(
    message: DeployerId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IGUnforgeable {
  g_private_body?: IGPrivate | null;
  g_deploy_id_body?: IGDeployId | null;
  g_deployer_id_body?: IGDeployerId | null;
}
declare export class GUnforgeable mixins IGUnforgeable {
  constructor(properties?: IGUnforgeable): this;
  g_private_body?: IGPrivate | null;
  g_deploy_id_body?: IGDeployId | null;
  g_deployer_id_body?: IGDeployerId | null;
  unf_instance?: "g_private_body" | "g_deploy_id_body" | "g_deployer_id_body";
  static create(properties?: IGUnforgeable): GUnforgeable;
  static encode(
    message: IGUnforgeable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGUnforgeable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GUnforgeable;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GUnforgeable;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): GUnforgeable;
  static toObject(
    message: GUnforgeable,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IGPrivate {
  id?: Uint8Array | null;
}
declare export class GPrivate mixins IGPrivate {
  constructor(properties?: IGPrivate): this;
  id: Uint8Array;
  static create(properties?: IGPrivate): GPrivate;
  static encode(
    message: IGPrivate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGPrivate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GPrivate;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GPrivate;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): GPrivate;
  static toObject(
    message: GPrivate,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IGDeployId {
  sig?: Uint8Array | null;
}
declare export class GDeployId mixins IGDeployId {
  constructor(properties?: IGDeployId): this;
  sig: Uint8Array;
  static create(properties?: IGDeployId): GDeployId;
  static encode(
    message: IGDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GDeployId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GDeployId;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): GDeployId;
  static toObject(
    message: GDeployId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IGDeployerId {
  publicKey?: Uint8Array | null;
}
declare export class GDeployerId mixins IGDeployerId {
  constructor(properties?: IGDeployerId): this;
  publicKey: Uint8Array;
  static create(properties?: IGDeployerId): GDeployerId;
  static encode(
    message: IGDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GDeployerId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GDeployerId;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): GDeployerId;
  static toObject(
    message: GDeployerId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEitherAny {
  type_url?: string | null;
  value?: Uint8Array | null;
}
declare export class EitherAny mixins IEitherAny {
  constructor(properties?: IEitherAny): this;
  type_url: string;
  value: Uint8Array;
  static create(properties?: IEitherAny): EitherAny;
  static encode(
    message: IEitherAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEitherAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EitherAny;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EitherAny;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EitherAny;
  static toObject(
    message: EitherAny,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEitherError {
  messages?: string[] | null;
}
declare export class EitherError mixins IEitherError {
  constructor(properties?: IEitherError): this;
  messages: string[];
  static create(properties?: IEitherError): EitherError;
  static encode(
    message: IEitherError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEitherError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EitherError;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EitherError;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EitherError;
  static toObject(
    message: EitherError,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEitherSuccess {
  response?: IEitherAny | null;
}
declare export class EitherSuccess mixins IEitherSuccess {
  constructor(properties?: IEitherSuccess): this;
  response?: IEitherAny | null;
  static create(properties?: IEitherSuccess): EitherSuccess;
  static encode(
    message: IEitherSuccess,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEitherSuccess,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EitherSuccess;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EitherSuccess;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EitherSuccess;
  static toObject(
    message: EitherSuccess,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEither {
  error?: IEitherError | null;
  success?: IEitherSuccess | null;
}
declare export class Either mixins IEither {
  constructor(properties?: IEither): this;
  error?: IEitherError | null;
  success?: IEitherSuccess | null;
  content?: "error" | "success";
  static create(properties?: IEither): Either;
  static encode(message: IEither, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEither,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Either;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Either;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Either;
  static toObject(
    message: Either,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
declare var google: typeof npm$namespace$google;

declare var npm$namespace$google: {
  protobuf: typeof npm$namespace$google$protobuf
};

declare var npm$namespace$google$protobuf: {
  Empty: typeof google$protobuf$Empty,
  Any: typeof google$protobuf$Any
};
declare interface google$protobuf$IEmpty {}

declare class google$protobuf$Empty mixins google$protobuf$IEmpty {
  constructor(properties?: google$protobuf$IEmpty): this;
  static create(properties?: google$protobuf$IEmpty): google$protobuf$Empty;
  static encode(
    message: google$protobuf$IEmpty,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IEmpty,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Empty;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Empty;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): google$protobuf$Empty;
  static toObject(
    message: google$protobuf$Empty,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}

declare interface google$protobuf$IAny {
  type_url?: string | null;
  value?: Uint8Array | null;
}

declare class google$protobuf$Any mixins google$protobuf$IAny {
  constructor(properties?: google$protobuf$IAny): this;
  type_url: string;
  value: Uint8Array;
  static create(properties?: google$protobuf$IAny): google$protobuf$Any;
  static encode(
    message: google$protobuf$IAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Any;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Any;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): google$protobuf$Any;
  static toObject(
    message: google$protobuf$Any,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
